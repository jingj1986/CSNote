**锁**

本章节先引用几种锁类型，并分别介绍其概念。

## 1. 介绍

### 1.1 锁的分类

**粒度** : 全局锁、表级锁、页锁、行级锁

**上锁方式**： 共享锁（读锁）、独占锁（写锁）

**思想**：乐观锁、悲观锁

**位置**：服务层锁、引擎层锁

**使用方式**: 隐式上锁、显式上锁

**InnoDB锁** :
* 共享锁（S）、排他锁（X）、意向共享锁（IS）、意向排它锁（IX）
*  Record Lock、Gap Lock、Next-key Lock

明确一个概念，每次用到的锁，都可以按照上述方式分类，也就是可以时行锁、共享锁，乐观锁、隐式锁。现有个初步概念，接下来介绍下各种类型锁是什么含义。

## 2 锁概念

### 2.1 粒度分类

**全局锁**
    全局锁是对整个数据库加锁，可以认为是数据库层级的锁；只是提供了全局读锁。加锁后整个数据库实例处于只读状态，后续的数据更新语句（数据增删改）、数据定义语句（建表、修改表结构等）和更新类事务的提交语句都被堵塞。由MySQL服务层实现。

**表级锁**
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁。
* 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。是引擎层的锁，一般引擎均支持，是存储引擎中最大颗粒度的锁定机制
* 元数据锁(meta data lock，MDL)，是对表结构而言，不需要显式使用；对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。由数据库服务层实现。

**行级锁**
    是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。是引擎层的锁。

**页锁** 
    是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。

**小结**

* 锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
* 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。
* 不同引擎支持的锁粒度

| | 行锁 | 页锁 | 表锁 |
| --- | --- | --- | --- |
| MyISAM |  |  | Y |
| Memory |  |  | Y |
| CSV |  |  | Y |
| BDB |  | Y  | Y |
| InnoDB | Y | | Y |

### 2.2 上锁方式


共享锁与独占锁是典型的读写锁，当加上读锁时，其他线程（或事务）可以继续读，但是不能写；而加上写锁之后，这个区域（表、页、行）就被独占了，只能等解锁了。其对应关系也就如下表所示

| | 共享锁 | 独占锁 |
| --- | --- | --- |
| 共享锁 | 兼容 | 冲突|
| 独占锁 | 冲突 | 冲突 |

对表级锁而言，就会有表共享读锁、表独占写锁；同样对行级锁而言，也就有行共享锁（S）、行排它锁（X）。

**封锁协议** 谈到X锁和S锁，就引出了封锁协议，就是运用X锁和S锁对数据对象进行加锁时约定的规则。其目的是在不同程序上保证数据的一致性。[摘自博客](https://blog.csdn.net/mulinsen77/article/details/89349080)

* 一级封锁：修改数据加x锁直到事务结束才释放。在此协议中，仅仅是读数据是不需要加锁的，所以只能解决丢失修改问题，不能解决脏读和不可重复读。
* 二级封锁：在一级封锁的基础上，加了一条：T事务在读取数据R之前必须先对其加上S锁，读完释放S锁。可以解决丢失修改和脏读（加了读锁就可以防止在读的期间其他事务进行修改，但是读完之后，事务结束之前，依然可能会其他事务进行修改，导致不可重复读）。
* 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。：解决了丢失修改、脏读和不可重复读的问题

### 2.3 思想

**定义**

> 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

> 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

**通用描述**

乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式

悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

**实现方式**

悲观锁：

    在对任意记录进行修改前，先尝试为该记录加上独占锁
    如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
    其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

乐观锁：（结合MVCC看）

    使用数据版本,为数据增加的一个版本标识。
    当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。
    当提交更新时，数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对;
        如果表当前版本号与第一次取出版本标识值相等，则予以更新，否则认为是过期数据。

**优缺点**

悲观锁: 实际上是采取了“先取锁在访问”的策略，为数据的处理安全提供了保证;<br>
但是在效率方面，由于额外的加锁机制产生了额外的开销，并且增加了死锁的机会。并且降低了并发性；当一个事物锁定一行数据的时候，其他事物必须等待该事务提交之后，才能操作这行数据。

乐观锁：并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁；<br>
但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

### 2.4 上锁位置

我们在1.2.1 介绍不同粒度下的锁，并说明了其所在位置。现在从位置看，会包含的锁类型：<br>
服务层：全局锁、表级元数据锁 <br>
引擎层：表锁，行级锁。不同引擎支持的锁粒度不同，见1.2.1的小结部分。

### 2.5 使用方式

**概念**

隐式

锁: 当多个客户端并发访问同一个数据的时候，为了保证数据的一致性，数据库管理系统会自动的为该数据加锁、解锁，这种被称为隐式锁。隐式锁无需开发人员维护（包括锁粒度、加锁时机、解锁时机等）。 <br>
显示锁：当时在某些特殊的情况下需要开发人员手动的进行加锁、解锁，这种锁方式被称为显式锁。对于显式锁而言，开发人员不仅要确定锁的粒度，还需要确定加锁的时机（何时加锁）、解锁的时机（何时解锁）以及所的类型。

**隐式锁**

* MyISAM <br>
```
  MyISAM存储引擎在执行sql语句之前会自动为涉及到的表加锁。
  在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁;
  在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁;
  这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁
```

* InnoDB <br>
```
  意向锁是 InnoDB 自动加的， 不需用户干预。
  对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)。
  对于普通 SELECT 语句，InnoDB 不会加任何锁。
  InnoDB采用两阶段锁定协议。在事务执行过程中，随时可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是同一时刻被释放。
  InnoDB会根据事务的隔离级别在需要的时候自动加锁。
```

**显示调用**

```
# 加全局读锁
Flush tables with read lock;

# 表加读锁、写锁；
lock tables t1 read,t2 wirte;
#释放表锁
unlock tables;

#行锁
select ... FOR UPDATE;          # 对读的行加X锁
select ... LOCK IN SHARE MODE;  # 对读的行加S锁
```
**补充**

[传送门](https://blog.csdn.net/qq_40378034/article/details/90904573)：上面提到使用 `Flush tables with read lock;` 当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。但是让整个库都只读，可能出现以下问题：

    如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
    如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟

在可重复读隔离级别下开启一个事务能够拿到一致性视图。
官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。single-transaction只适用于所有的表使用事务引擎的库

既然要全库只读，为什么不使用set global readonly=true的方式？

    在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大
    在异常处理机制上有差异：如果执行该命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态；
                而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高

**补充1**

外键与锁；当使用了外键的子表执行插入或更新时，会主动的对父表加一个S锁，即 `select ... Lock in share mode`的方式；此时如果父表已经加了X锁，子表的操作就会被堵塞。

### 2.6 InnoDB 锁

#### 2.6.1 意向锁

**来源**

为什么需要意向锁，肯定是不适用意向锁会遇到一些问题或者困难，而使用意向锁会很好的解决。我们来看看 [详解mysql的各种锁](https://zhuanlan.zhihu.com/p/52312376) 中的例子。

```
1. 假设有事务A执行update的语句，如 update user_info set name='AAA' where id = 6; 它会对索引字为6的节点加锁
2. 此时又有事务B要执行修改操作，如 update user_info set name='BBB'; 
    . 因为事务B是对整个表进行修改操作，那么此SQL是需要对整个表进行加排它锁的（update加锁类型为排他锁）；
    . 首先做的第一件事是先检查这个表有没有被别的事务锁住，只要有事务对表里的任何一行数据加了共享锁或排他锁我们就无法对整个表加锁（排他锁不能与任何属性的锁兼容）；
    . INNODB锁的机制是基于行锁，那么这个时候我们会对整个索引每个节点一个个检查，我们需要检查每个节点是否被别的事务加了共享锁或排它锁；
    . 最后检查到索引ID为6的节点被事务A锁住了，最后导致事务B只能等待事务A锁的释放才能进行加锁操作。
3. 这就引出了问题：在事务A未提交前，每个像B这种需要对user_info加持表锁的事务都需要遍历整个索引树，才能知道自己是否能够进行加锁，太浪费时间和损耗数据库性能
4. 所以就有了意向锁的概念
```

**解释**

InnoDB 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，包括意向共享锁（IS）、意向排他锁（IX）；
意向锁的作用就是协调行锁和表锁之间的关系的，是将行锁从另一个角度提高到了表锁的等级（伪表锁），与表锁进行判断。<br>
意向锁与行级的共享锁（S）、独占锁（X）之间兼容情况如下表：
| | X | IX | S | IS |
| --- | --- | --- | --- | --- |
| X | 冲突 | 冲突 | 冲突 | 冲突 |
| IX | 冲突 | 兼容 | 冲突  | 兼容 |
| S | 冲突 | 冲突 | 兼容 | 兼容 |
| IS | 冲突 | 兼容 | 兼容 | 兼容 | 

**使用**

如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。<br>
意向锁是InnDB自动加的，不需要用户的干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。<br>
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。[传送梦](https://www.cnblogs.com/huangfuyuan/p/9510022.html)<br>

（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。<br>
（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。<br>
（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。<br>
（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。

#### 2.6.2 行级锁

* Record Lock（记录锁，单行记录）
* Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）
* Next-Key Lock（临建锁，Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）

有观点认为这是InnoDB行锁的三种算法。

该部分信息主要参考 [再谈mysql锁机制及原理—锁的诠释](https://www.cnblogs.com/zhoulujun/p/11710318.html)。也有观点

**Record Lock**

事务加锁后锁住的只是表的某一条记录；精准条件命中，并且命中的条件字段是唯一索。<br>
加了记录锁之后可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。

**gap lcok**

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于**键值在条件范围内但并不存在的记录**，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。<br>

使用的目的： 1. 防止幻读，以满足相关隔离级别的要求；2. 满足恢复和复制的需要； <br>
RR事务隔离级别下, 1.使用普通索引锁定； 2. 使用多列唯一索引；3. 使用唯一索引锁定多行记录 均会产生间隙锁； <br>
引申建议:  在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

**Next-Key Lock**

INNODB的行锁默认算法，它是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。

条件：范围查询并命中，查询命中了索引。<br>
作用：结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。

**实验**

在[MySQL的锁机制 - 记录锁、间隙锁、临键锁](https://www.cnblogs.com/zhoulujun/p/11710318.html) 中，作者在 `唯一索引`、`普通索引`上操作，出现了间隙锁，从而导致某些事务阻塞的情况。并得出一些结论
```
1. 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁; 
2. 对于查找某一范围内的查询语句，会产生间隙锁;
3. 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；
4. 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。
```

间隙锁只有在事务隔离级别 RR 中才会产生, RC级别下失效。前面介绍MVCC时提到，RR级别下使用MVCC仍然会存在幻读问题，就是采用这里的Next-Key Lock(或者Gap Lock)方式解决，从而达到串行化的效果。

**补充**

[MySQL锁(表锁,行锁,共享锁,排它锁,间隙锁)使用详解](https://www.cnblogs.com/drizzle-xu/p/10435638.html) 对InnoDB使用行锁、表锁提到一些阐述：
对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。

1. 情况1：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。 <br>
2. 情况2：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。<br>

当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。

在InnoDB下，使用表锁要注意以下两点：

1. 使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、InnoDB_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁，否则，InnoDB将无法自动检测并处理这种死锁。<br>
2. 在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。


## 3. 死锁

### 3.1 介绍

事务T1封锁了数据A，事务T2封锁了数据B，然后T1请求封锁B，与此同时T2也请求封锁A，但因为两个事务的请求都需要等待对方释放锁，这样就出现了死锁。这和我们常说的死锁原理类似。

像MyISAM这样仅支持到表级锁的引擎，不会出现死锁。<br>
而支持行锁的引擎像InnoDB引擎，则会有可能出现死锁。


### 3.2 预防

前面我们已经介绍，InnoDB使用两阶段锁协议:在事务执行过程中，随时可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是同一时刻被释放。所以如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，并且要让不同的事务，采用相同的加锁顺序。我们来看[例子](https://yq.aliyun.com/articles/626848)。

有一个扣减库存的案例：
```
1. 扣减库存: update t_inventory set count=count-5 where id=${id} and count >= 5;
2. 锁住用户: select * from t_user_account where user_id=123 for update;
3. 插入订单记录: insert into t_trans; 
```

如果采用 1-2-3的顺序执行，库存表（t_inventory）上锁时间为从1开始一值到事务提交，跨三个任务；而如果采用2-3-1的顺序执行，库存表锁住时间仅需要一个任务的时间。而库存往往是最重要的热点，是整个系统的瓶颈，所以采用后面的顺序可以显著提高性能。

而在执行时，不同事务必须采用相同的加锁顺序：如果事务A采用1-2-3顺序，事务B采用2-3-1的顺序，则发生死锁的风险就会提高。

还可以将一些简单的判断逻辑写到update的谓词里面，以减少加锁时间。如下，方案2的锁住时间就会少1个任务时间。

```
/*方案1*/
 begin:
 int count = select count from t_inventory for update;
 if count >= 5:
     update t_inventory set count=count-5 where id =123
     commit 
 else
     rollback

/*方案1*/
 begin:
    int rows = update t_inventory set count=count-5 where id =123 and count >=5
 if rows > 0:
    commit;
 ele 
    rollback;
```

### 3.3 诊断与解除

死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。

数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。

死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。

发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决。

## 4.  优化

该节内容摘自 [mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)

### 4.1 MyISAM表锁优化建议

　　对于MyISAM存储引擎，虽然使用表级锁定在锁定实现的过程中比实现行级锁定或者页级锁所带来的附加成本都要小，锁定本身所消耗的资源也是最少。但是由于锁定的颗粒度比较到，所以造成锁定资源的争用情况也会比其他的锁定级别都要多，从而在较大程度上会降低并发处理能力。所以，在优化MyISAM存储引擎锁定问题的时候，最关键的就是如何让其提高并发度。由于锁定级别是不可能改变的了，所以我们首先需要尽可能让锁定的时间变短，然后就是让可能并发进行的操作尽可能的并发。

#### 4.1.1 查询表级锁争用情况

MySQL内部有两组专门的状态变量记录系统内部锁资源争用情况：

```
mysql> show status like 'table%';
+----------------------------+---------+
| Variable_name              | Value   |
+----------------------------+---------+
| Table_locks_immediate      | 100     |
| Table_locks_waited         | 11      |
+----------------------------+---------+
```
这里有两个状态变量记录MySQL内部表级锁定的情况，两个变量说明如下：

    Table_locks_immediate：产生表级锁定的次数；
    Table_locks_waited：出现表级锁定争用而发生等待的次数；

两个状态值都是从系统启动后开始记录，出现一次对应的事件则数量加1。如果这里的Table_locks_waited状态值比较高，那么说明系统中表级锁定争用现象比较严重，就需要进一步分析为什么会有较多的锁定资源争用了。

#### 4.1.2 缩短锁定时间

如何让锁定时间尽可能的短呢？唯一的办法就是让我们的Query执行时间尽可能的短。

　　a)尽两减少大的复杂Query，将复杂Query分拆成几个小的Query分布进行；
　　b)尽可能的建立足够高效的索引，让数据检索更迅速；
　　c)尽量让MyISAM存储引擎的表只存放必要的信息，控制字段类型；
　　d)利用合适的机会优化MyISAM表数据文件。

#### 4.1.3 分离能并行的操作

说到MyISAM的表锁，而且是读写互相阻塞的表锁，可能有些人会认为在MyISAM存储引擎的表上就只能是完全的串行化，没办法再并行了。大家不要忘记了，MyISAM的存储引擎还有一个非常有用的特性，那就是ConcurrentInsert（并发插入）的特性。<br>
MyISAM存储引擎有一个控制是否打开Concurrent Insert功能的参数选项：concurrent_insert，可以设置为0，1或者2。三个值的具体说明如下：

    concurrent_insert=2，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录；
    concurrent_insert=1，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置；
    concurrent_insert=0，不允许并发插入。

可以利用MyISAM存储引擎的并发插入特性，来解决应用中对同一表查询和插入的锁争用。例如，将concurrent_insert系统变量设为2，总是允许并发插入；同时，通过定期在系统空闲时段执行OPTIMIZE TABLE语句来整理空间碎片，收回因删除记录而产生的中间空洞。

#### 4.1.4 合理利用读写优先级

MyISAM存储引擎的是读写互相阻塞的，那么，一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，MySQL如何处理呢？

答案是:写进程先获得锁。不仅如此，即使读请求先到锁等待队列，写请求后到，写锁也会插到读锁请求之前。

这是因为MySQL的表级锁定对于读和写是有不同优先级设定的，默认情况下是写优先级要大于读优先级。所以，如果我们可以根据各自系统环境的差异决定读与写的优先级：

    通过执行命令SET LOW_PRIORITY_UPDATES=1，使该连接读比写的优先级高。如果我们的系统是一个以读为主，可以设置此参数，如果以写为主，则不用设置；
    通过指定INSERT、UPDATE、DELETE语句的LOW_PRIORITY属性，降低该语句的优先级。

虽然上面方法都是要么更新优先，要么查询优先的方法，但还是可以用其来解决查询相对重要的应用（如用户登录系统）中，读锁等待严重的问题。另外，MySQL也提供了一种折中的办法来调节读写冲突，即给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。

这里还要强调一点：一些需要长时间运行的查询操作，也会使写进程“饿死”，因此，应用中应尽量避免出现长时间运行的查询操作，不要总想用一条SELECT语句来解决问题，因为这种看似巧妙的SQL语句，往往比较复杂，执行时间较长，在可能的情况下可以通过使用中间表等措施对SQL语句做一定的“分解”，使每一步查询都能在较短时间完成，从而减少锁冲突。如果复杂查询不可避免，应尽量安排在数据库空闲时段执行，比如一些定期统计可以安排在夜间执行。



### 4.2 InnoDB行锁优化建议

InnoDB存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一些，但是在整体并发处理能力方面要远远优于MyISAM的表级锁定的。当系统并发量较高的时候，InnoDB的整体性能和MyISAM相比就会有比较明显的优势了。

但是，InnoDB的行级锁定同样也有其脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能表现不仅不能比MyISAM高，甚至可能会更差。

#### 4.2.1 合理利用,扬长避短

```
　　a)尽可能让所有的数据检索都通过索引来完成，从而避免InnoDB因为无法通过索引键加锁而升级为表级锁定；
　　b)合理设计索引，让InnoDB在索引键上面加锁的时候尽可能准确，尽可能的缩小锁定范围，避免造成不必要的锁定而影响其他Query的执行；
　　c)尽可能减少基于范围的数据检索过滤条件，避免因为间隙锁带来的负面影响而锁定了不该锁定的记录；
　　d)尽量控制事务的大小，减少锁定的资源量和锁定时间长度；
　　e)在业务环境允许的情况下，尽量使用较低级别的事务隔离，以减少MySQL因为实现事务隔离级别所带来的附加成本。
```

#### 4.2.2 减少死锁概率

由于InnoDB的行级锁定和事务性，所以肯定会产生死锁，下面是一些比较常用的减少死锁产生概率的小建议：

    a) 类似业务模块中，尽可能按照相同的访问顺序来访问，防止产生死锁；
    b) 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
    c) 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率。

#### 4.2.3 检查行锁

可以通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况：
```
mysql> show status like 'InnoDB_row_lock%';
+-------------------------------+-------+
| Variable_name                 | Value |
+-------------------------------+-------+
| InnoDB_row_lock_current_waits | 0     |
| InnoDB_row_lock_time          | 0     |
| InnoDB_row_lock_time_avg      | 0     |
| InnoDB_row_lock_time_max      | 0     |
| InnoDB_row_lock_waits         | 0     |
+-------------------------------+-------+
```

InnoDB 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：

　　InnoDB_row_lock_current_waits：当前正在等待锁定的数量；
　　InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；
　　InnoDB_row_lock_time_avg：每次等待所花平均时间；
　　InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
　　InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；

对于这5个状态变量，比较重要的主要是 `InnoDB_row_lock_time_avg`（等待平均时长），`InnoDB_row_lock_waits`（等待总次数）以及`InnoDB_row_lock_time`（等待总时长）这三项。尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。

如果发现锁争用比较严重，如`InnoDB_row_lock_waits`和`InnoDB_row_lock_time_avg`的值比较高，还可以通过设置InnoDB Monitors 来进一步观察发生锁冲突的表、数据行等，并分析锁争用的原因。

锁冲突的表、数据行等，并分析锁争用的原因。具体方法如下：
```
mysql> create table InnoDB_monitor(a INT) engine=InnoDB;
```
然后就可以用下面的语句来进行查看：
```
mysql> show engine InnoDB status;
```
监视器可以通过发出下列语句来停止查看：
```
mysql> drop table InnoDB_monitor;
```
设置监视器后，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等，便于进行进一步的分析和问题的确定。

可能会有读者朋友问为什么要先创建一个叫`InnoDB_monitor`的表呢？因为创建该表实际上就是告诉InnoDB我们开始要监控他的细节状态了，然后InnoDB就会将比较详细的事务以及锁定信息记录进入MySQL的errorlog中，以便我们后面做进一步分析使用。<br>
打开监视器以后，默认情况下每15秒会向日志中记录监控的内容，如果长时间打开会导致.err文件变得非常的巨大，所以用户在确认问题原因之后，要记得删除监控表以关闭监视器，或者通过使用“--console”选项来启动服务器以关闭写日志文件。


## 参考资料
1. [MySQL锁(表锁,行锁,共享锁,排它锁,间隙锁)使用详解](https://www.cnblogs.com/drizzle-xu/p/10435638.html)
2. [MySQL的锁机制和加锁原理](https://blog.csdn.net/qq_38238296/article/details/88362999)
3. [mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)
4. [mysql锁](https://www.cnblogs.com/unclewang666/p/11153241.html)
5. [再谈mysql锁机制及原理—锁的诠释](https://www.cnblogs.com/zhoulujun/p/11710318.html)
