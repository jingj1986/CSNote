**锁**

本章节先引用几种锁类型，并分别介绍其概念。

## 1. 介绍

### 1.1 锁的分类

**粒度** : 全局锁、表级锁、页锁、行级锁

**上锁方式**： 共享锁（读锁）、独占锁（写锁）

**思想**：乐观锁、悲观锁

**位置**：服务层锁、引擎层锁

**使用方式**: 隐式上锁、显式上锁

**InnoDB锁** :
* 共享锁（S）、排他锁（X）、意向共享锁（IS）、意向排它锁（IX）
*  Record Lock、Gap Lock、Next-key Lock

明确一个概念，每次用到的锁，都可以按照上述方式分类，也就是可以时行锁、共享锁，乐观锁、隐式锁。现有个初步概念，接下来介绍下各种类型锁是什么含义。

### 1.2 锁概念

#### 1.2.1 粒度分类

**全局锁**
    全局锁是对整个数据库加锁，可以认为是数据库层级的锁；只是提供了全局读锁。加锁后整个数据库实例处于只读状态，后续的数据更新语句（数据增删改）、数据定义语句（建表、修改表结构等）和更新类事务的提交语句都被堵塞。由MySQL服务层实现。

**表级锁**
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁。
* 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。是引擎层的锁，一般引擎均支持，是存储引擎中最大颗粒度的锁定机制
* 元数据锁(meta data lock，MDL)，是对表结构而言，不需要显式使用；对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。由数据库服务层实现。

**行级锁**
    是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。是引擎层的锁。

**页锁** 
    是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。

**小结**

* 锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
* 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。
* 不同引擎支持的锁粒度

| | 行锁 | 页锁 | 表锁 |
| --- | --- | --- | --- |
| MyISAM |  |  | Y |
| Memory |  |  | Y |
| CSV |  |  | Y |
| BDB |  | Y  | Y |
| InnoDB | Y | | Y |

#### 1.2.2 上锁方式


共享锁与独占锁是典型的读写锁，当加上读锁时，其他线程（或事务）可以继续读，但是不能写；而加上写锁之后，这个区域（表、页、行）就被独占了，只能等解锁了。其对应关系也就如下表所示

| | 共享锁 | 独占锁 |
| --- | --- | --- |
| 共享锁 | 兼容 | 冲突|
| 独占锁 | 冲突 | 冲突 |

对表级锁而言，就会有表共享读锁、表独占写锁；同样对行级锁而言，也就有行共享锁（S）、行排它锁（X）。

**封锁协议** 谈到X锁和S锁，就引出了封锁协议，就是运用X锁和S锁对数据对象进行加锁时约定的规则。其目的是在不同程序上保证数据的一致性。[摘自博客](https://blog.csdn.net/mulinsen77/article/details/89349080)

* 一级封锁：修改数据加x锁直到事务结束才释放。在此协议中，仅仅是读数据是不需要加锁的，所以只能解决丢失修改问题，不能解决脏读和不可重复读。
* 二级封锁：在一级封锁的基础上，加了一条：T事务在读取数据R之前必须先对其加上S锁，读完释放S锁。可以解决丢失修改和脏读（加了读锁就可以防止在读的期间其他事务进行修改，但是读完之后，事务结束之前，依然可能会其他事务进行修改，导致不可重复读）。
* 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。：解决了丢失修改、脏读和不可重复读的问题

#### 1.2.3 思想

**定义**

> 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

> 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

**通用描述**

乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式

悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

**实现方式**

悲观锁：

    在对任意记录进行修改前，先尝试为该记录加上独占锁
    如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
    其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

乐观锁：（结合MVCC看）

    使用数据版本,为数据增加的一个版本标识。
    当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。
    当提交更新时，数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对;
        如果表当前版本号与第一次取出版本标识值相等，则予以更新，否则认为是过期数据。

**优缺点**

悲观锁: 实际上是采取了“先取锁在访问”的策略，为数据的处理安全提供了保证;<br>
但是在效率方面，由于额外的加锁机制产生了额外的开销，并且增加了死锁的机会。并且降低了并发性；当一个事物锁定一行数据的时候，其他事物必须等待该事务提交之后，才能操作这行数据。

乐观锁：并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁；<br>
但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

#### 1.2.4 上锁位置

我们在1.2.1 介绍不同粒度下的锁，并说明了其所在位置。现在从位置看，会包含的锁类型：<br>
服务层：全局锁、表级元数据锁 <br>
引擎层：表锁，行级锁。不同引擎支持的锁粒度不同，见1.2.1的小结部分。

#### 1.2.5 使用方式

**概念**

隐式锁: 当多个客户端并发访问同一个数据的时候，为了保证数据的一致性，数据库管理系统会自动的为该数据加锁、解锁，这种被称为隐式锁。隐式锁无需开发人员维护（包括锁粒度、加锁时机、解锁时机等）。 <br>
显示锁：当时在某些特殊的情况下需要开发人员手动的进行加锁、解锁，这种锁方式被称为显式锁。对于显式锁而言，开发人员不仅要确定锁的粒度，还需要确定加锁的时机（何时加锁）、解锁的时机（何时解锁）以及所的类型。

**隐式锁**

* MyISAM <br>
```
  MyISAM存储引擎在执行sql语句之前会自动为涉及到的表加锁。
  在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁;
  在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁;
  这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁
```

* InnoDB <br>
```
  意向锁是 InnoDB 自动加的， 不需用户干预。
  对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)。
  对于普通 SELECT 语句，InnoDB 不会加任何锁。
  InnoDB采用两阶段锁定协议。在事务执行过程中，随时可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是同一时刻被释放。
  InnoDB会根据事务的隔离级别在需要的时候自动加锁。
```

**显示调用**

```
# 加全局读锁
Flush tables with read lock;

# 表加读锁、写锁；
lock tables t1 read,t2 wirte;
#释放表锁
unlock tables;

#行锁
select ... FOR UPDATE;          # 对读的行加X锁
select ... LOCK IN SHARE MODE;  # 对读的行加S锁
```
**补充**

[传送门](https://blog.csdn.net/qq_40378034/article/details/90904573)：上面提到使用 `Flush tables with read lock;` 当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。但是让整个库都只读，可能出现以下问题：

    如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
    如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟

在可重复读隔离级别下开启一个事务能够拿到一致性视图。
官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。single-transaction只适用于所有的表使用事务引擎的库

既然要全库只读，为什么不使用set global readonly=true的方式？

    在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大
    在异常处理机制上有差异：如果执行该命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态；
                而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高

#### 1.2.6 InnoDB 锁

##### 1.2.6.1 意向锁

**来源**

为什么需要意向锁，肯定是不适用意向锁会遇到一些问题或者困难，而使用意向锁会很好的解决。我们来看看 [详解mysql的各种锁](https://zhuanlan.zhihu.com/p/52312376) 中的例子。

```
1. 假设有事务A执行update的语句，如 update user_info set name='AAA' where id = 6; 它会对索引字为6的节点加锁
2. 此时又有事务B要执行修改操作，如 update user_info set name='BBB'; 
    . 因为事务B是对整个表进行修改操作，那么此SQL是需要对整个表进行加排它锁的（update加锁类型为排他锁）；
    . 首先做的第一件事是先检查这个表有没有被别的事务锁住，只要有事务对表里的任何一行数据加了共享锁或排他锁我们就无法对整个表加锁（排他锁不能与任何属性的锁兼容）；
    . INNODB锁的机制是基于行锁，那么这个时候我们会对整个索引每个节点一个个检查，我们需要检查每个节点是否被别的事务加了共享锁或排它锁；
    . 最后检查到索引ID为6的节点被事务A锁住了，最后导致事务B只能等待事务A锁的释放才能进行加锁操作。
3. 这就引出了问题：在事务A未提交前，每个像B这种需要对user_info加持表锁的事务都需要遍历整个索引树，才能知道自己是否能够进行加锁，太浪费时间和损耗数据库性能
4. 所以就有了意向锁的概念
```

**解释**

InnoDB 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁，包括意向共享锁（IS）、意向排他锁（IX）；
意向锁的作用就是协调行锁和表锁之间的关系的，是将行锁从另一个角度提高到了表锁的等级（伪表锁），与表锁进行判断。<br>
意向锁与行级的共享锁（S）、独占锁（X）之间兼容情况如下表：
| | X | IX | S | IS |
| --- | --- | --- | --- | --- |
| X | 冲突 | 冲突 | 冲突 | 冲突 |
| IX | 冲突 | 兼容 | 冲突  | 兼容 |
| S | 冲突 | 冲突 | 兼容 | 兼容 |
| IS | 冲突 | 兼容 | 兼容 | 兼容 | 

**使用**

如果一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。<br>
意向锁是InnDB自动加的，不需要用户的干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。<br>
InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。[传送梦](https://www.cnblogs.com/huangfuyuan/p/9510022.html)<br>

（1）在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。<br>
（2）由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。<br>
（3）当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。<br>
（4）即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。

##### 1.2.6.2 行级锁

* Record Lock（记录锁，单行记录）
* Gap Lock（间隙锁，锁定一个范围，但不包含锁定记录）
* Next-Key Lock（临建锁，Record Lock + Gap Lock，锁定一个范围，并且锁定记录本身， MySql 防止幻读，就是使用此锁实现）

该部分信息主要参考 [再谈mysql锁机制及原理—锁的诠释](https://www.cnblogs.com/zhoulujun/p/11710318.html)。

**Record Lock**

事务加锁后锁住的只是表的某一条记录；精准条件命中，并且命中的条件字段是唯一索。<br>
加了记录锁之后可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。

**gap lcok**

当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于**键值在条件范围内但并不存在的记录**，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。<br>

使用的目的： 1. 防止幻读，以满足相关隔离级别的要求；2. 满足恢复和复制的需要； <br>
RR事务隔离级别下, 1.使用普通索引锁定； 2. 使用多列唯一索引；3. 使用唯一索引锁定多行记录 均会产生间隙锁； <br>
引申建议:  在使用范围条件检索并锁定记录时，InnoDB这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范围条件。

**Next-Key Lock**

INNODB的行锁默认算法，它是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。

条件：范围查询并命中，查询命中了索引。<br>
作用：结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。

**实验**

在[MySQL的锁机制 - 记录锁、间隙锁、临键锁](https://www.cnblogs.com/zhoulujun/p/11710318.html) 中，作者在 `唯一索引`、`普通索引`上操作，出现了间隙锁，从而导致某些事务阻塞的情况。并得出一些结论
```
1. 对于指定查询某一条记录的加锁语句，如果该记录不存在，会产生记录锁和间隙锁，如果记录存在，则只会产生记录锁; 
2. 对于查找某一范围内的查询语句，会产生间隙锁;
3. 在普通索引列上，不管是何种查询，只要加锁，都会产生间隙锁，这跟唯一索引不一样；
4. 在普通索引跟唯一索引中，数据间隙的分析，数据行是优先根据普通索引排序，再根据唯一索引排序。
```

间隙锁只有在事务隔离级别 RR 中才会产生, RC级别下失效。前面介绍MVCC时提到，RR级别下使用MVCC仍然会存在幻读问题，就是采用这里的Next-Key Lock(或者Gap Lock)方式解决，从而达到串行化的效果。

## 二阶段

## 死锁

## 优化

## 其他问题

## 参考资料
1. [iMySQL锁(表锁,行锁,共享锁,排它锁,间隙锁)使用详解](https://www.cnblogs.com/drizzle-xu/p/10435638.html)
2. [MySQL的锁机制和加锁原理](https://blog.csdn.net/qq_38238296/article/details/88362999)
3. [mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)
4. [mysql锁](https://www.cnblogs.com/unclewang666/p/11153241.html)
5. [再谈mysql锁机制及原理—锁的诠释](https://www.cnblogs.com/zhoulujun/p/11710318.html)
