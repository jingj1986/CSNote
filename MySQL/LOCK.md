**锁**

本章节先引用几种锁类型，并分别介绍其概念。

## 1. 介绍

### 1.1 锁的分类

**粒度** : 全局锁、表级锁、页锁、行级锁

**上锁方式**： 共享锁（读锁）、独占锁（写锁）

**思想**：乐观锁、悲观锁

**位置**：服务层锁、引擎层锁

**使用方式**: 隐式上锁、显式上锁

**InnoDB行锁** :
* 共享锁（S）、排他锁（X）、意向共享锁（IS）、意向排它锁（IX）
*  Record Lock、Gap Lock、Next-key Lock

明确一个概念，每次用到的锁，都可以按照上述方式分类，也就是可以时行锁、共享锁，乐观锁、隐式锁。现有个初步概念，接下来介绍下各种类型锁是什么含义。

### 1.2 锁概念

#### 1.2.1 粒度分类

**全局锁**
    全局锁是对整个数据库加锁，可以认为是数据库层级的锁；只是提供了全局读锁。加锁后整个数据库实例处于只读状态，后续的数据更新语句（数据增删改）、数据定义语句（建表、修改表结构等）和更新类事务的提交语句都被堵塞。由MySQL服务层实现。

**表级锁**
MySQL里面表级别的锁有两种：一种是表锁，一种是元数据锁。
* 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低。是引擎层的锁，一般引擎均支持，是存储引擎中最大颗粒度的锁定机制
* 元数据锁(meta data lock，MDL)，是对表结构而言，不需要显式使用；对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。由数据库服务层实现。

**行级锁**
    是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。有可能会出现死锁的情况。是引擎层的锁。

**页锁** 
    是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。

**小结**

* 锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。
* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；
* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高；    
* 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。
* 适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。
* 不同引擎支持的锁粒度

| | 行锁 | 页锁 | 表锁 |
| --- | --- | --- | --- |
| MyISAM |  |  | Y |
| Memory |  |  | Y |
| CSV |  |  | Y |
| BDB |  | Y  | Y |
| InnoDB | Y | | Y |

#### 1.2.2 上锁方式


共享锁与独占锁是典型的读写锁，当加上读锁时，其他线程（或事务）可以继续读，但是不能写；而加上写锁之后，这个区域（表、页、行）就被独占了，只能等解锁了。其对应关系也就如下表所示

| | 共享锁 | 独占锁 |
| --- | --- | --- |
| 共享锁 | 兼容 | 冲突|
| 独占锁 | 冲突 | 冲突 |

对表级锁而言，就会有表共享读锁、表独占写锁；同样对行级锁而言，也就有行共享锁（S）、行排它锁（X）。

**封锁协议** 谈到X锁和S锁，就引出了封锁协议，就是运用X锁和S锁对数据对象进行加锁时约定的规则。其目的是在不同程序上保证数据的一致性。[摘自博客](https://blog.csdn.net/mulinsen77/article/details/89349080)

* 一级封锁：修改数据加x锁直到事务结束才释放。在此协议中，仅仅是读数据是不需要加锁的，所以只能解决丢失修改问题，不能解决脏读和不可重复读。
* 二级封锁：在一级封锁的基础上，加了一条：T事务在读取数据R之前必须先对其加上S锁，读完释放S锁。可以解决丢失修改和脏读（加了读锁就可以防止在读的期间其他事务进行修改，但是读完之后，事务结束之前，依然可能会其他事务进行修改，导致不可重复读）。
* 三级封锁协议：一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。：解决了丢失修改、脏读和不可重复读的问题

#### 1.2.3 思想

**定义**

> 在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作对某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。

> 在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。

**通用描述**

乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式

悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。

**实现方式**

悲观锁：

    在对任意记录进行修改前，先尝试为该记录加上独占锁
    如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。
    如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。
    其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。

乐观锁：（结合MVCC看）

    使用数据版本,为数据增加的一个版本标识。
    当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。
    当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。

**优缺点**

悲观锁: 实际上是采取了“先取锁在访问”的策略，为数据的处理安全提供了保证;<br>
但是在效率方面，由于额外的加锁机制产生了额外的开销，并且增加了死锁的机会。并且降低了并发性；当一个事物锁定一行数据的时候，其他事物必须等待该事务提交之后，才能操作这行数据。

乐观锁：并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁；<br>
但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。

#### 1.2.4 上锁位置

我们在1.2.1 介绍不同粒度下的锁，并说明了其所在位置。现在从位置看，会包含的锁类型：<br>
服务层：全局锁、表级元数据锁 <br>
引擎层：表锁，行级锁。不同引擎支持的锁粒度不同，见1.2.1的小结部分。

### 1.2.5 使用方式

**概念**

隐式锁: 当多个客户端并发访问同一个数据的时候，为了保证数据的一致性，数据库管理系统会自动的为该数据加锁、解锁，这种被称为隐式锁。隐式锁无需开发人员维护（包括锁粒度、加锁时机、解锁时机等）。 <br>
显示锁：当时在某些特殊的情况下需要开发人员手动的进行加锁、解锁，这种锁方式被称为显式锁。对于显式锁而言，开发人员不仅要确定锁的粒度，还需要确定加锁的时机（何时加锁）、解锁的时机（何时解锁）以及所的类型。

**隐式锁**

* MyISAM <br>
```
  MyISAM存储引擎在执行sql语句之前会自动为涉及到的表加锁。
  MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁
```

* InnoDB <br>
```
  意向锁是 InnoDB 自动加的， 不需用户干预。
  对于 UPDATE、 DELETE 和 INSERT 语句， InnoDB 会自动给涉及数据集加排他锁（X)。
  对于普通 SELECT 语句，InnoDB 不会加任何锁。
  InnoDB采用两阶段锁定协议。在事务执行过程中，随时可以执行锁定，锁只有在执行commit或者rollback的时候才会释放，并且所有的锁都是同一时刻被释放。
  InnoDB会根据事务的隔离级别在需要的时候自动加锁。
```

**显示调用**

```
# 加全局读锁
Flush tables with read lock;

# 表加读锁、写锁；
lock tables t1 read,t2 wirte;
#释放表锁
unlock tables;

#行锁
select ... FOR UPDATE;          # 对读的行加X锁
select ... LOCK IN SHARE MODE;  # 对读的行加S锁
```
**补充**

[传送门](https://blog.csdn.net/qq_40378034/article/details/90904573)：上面提到使用 `Flush tables with read lock;` 当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都select出来存成文本。但是让整个库都只读，可能出现以下问题：

    如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆
    如果在从库上备份，那么在备份期间从库不能执行主库同步过来的binlog，会导致主从延迟

在可重复读隔离级别下开启一个事务能够拿到一致性视图。
官方自带的逻辑备份工具是mysqldump。当mysqldump使用参数–single-transaction的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于MVCC的支持，这个过程中数据是可以正常更新的。single-transaction只适用于所有的表使用事务引擎的库

既然要全库只读，为什么不使用set global readonly=true的方式？

    在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此修改global变量的方式影响面更大
    在异常处理机制上有差异。如果执行Flush tables with read lock命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高

### 1.2.6 InnoDB 行锁


## 参考资料
1. [iMySQL锁(表锁,行锁,共享锁,排它锁,间隙锁)使用详解](https://www.cnblogs.com/drizzle-xu/p/10435638.html)
2. [MySQL的锁机制和加锁原理](https://blog.csdn.net/qq_38238296/article/details/88362999)
3. [mysql锁——innodb的行级锁](https://www.cnblogs.com/huangfuyuan/p/9510022.html)
4. [mysql锁](https://www.cnblogs.com/unclewang666/p/11153241.html)
5. [再谈mysql锁机制及原理—锁的诠释](https://www.cnblogs.com/zhoulujun/p/11710318.html)
