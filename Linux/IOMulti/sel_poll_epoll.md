## select
### 基本理解
1. fd_set 是文件描述符的位图（采用bit位表示），可能会比较大；我们在使用时，会先将其清空，然后在对想要select 的文件描述符置1
    `FD_ZERO(fds); FD_SET(fd, fds);` <br>
  这样select时，就会将fds中为1多对应的描述符查询了。

2. 那刚开始启动socket服务时，fds中可能只有一个该socket句柄设置为1了，所以只有能收到该句柄的信息；<br>
  select收到后，用 `FD_ISSET(s_fd, fds)` 来判断该s_fd是否有消息（推测，如果select后，如果没有该句柄信息，fds上对应的bit位会置0）。<br>
  所以，如果时监听的消息，相当于有新请求，则accept建立连接句柄，并将句柄放入fds中

3. select有返回，而且不是对socket的新请求时，接受处理客户端消息; <br>
    执行时，也需要对fds中bits逐个判断 FD_ISSET()

4. 因为fds内消息会经常被重置，所以用一个句柄数组保存当前正在使用的句柄信息。（-1表示没有使用；否则在使用。处理结束后，需要关闭，并设置为-1）

5. 如果循环操作时，重新执行select之前，要保证fds中的信息正确；<br>
    如果认为fds中信息还正确，可继续使用，但实际上，文件描述符、内核都可能发生变化了，所以需要按照上面1的方式重新设置。

### 缺点

1. 可监控的文件描述符集大小有限制，sizeof(fd_set)根据机器不同，这边的数值为128字节，说明可监控文件描述符为1024个
    （可以自己设置调整）
2. 每次调用select,都需要自己手动设置fd_set，从接口使用来说不方便，并且输入输出参数为一个值，还需要自己维护第三个变量
3. 每次调用select 都需要将fd集从用户态拷贝到内核态，这边为128*3字节，虽然感觉上不大，但是拷贝次数太频繁
4. 每次不管是内核还是我们自己在使用的时候，都要遍历fd，开销也挺大的

### 注意

select 设置的最大句柄数要+1 (是个数，不是数值，所以要用最大句柄值+1)

## poll

### 基本理解

1. 使用pollfd结构体存放信息；执行poll之前，将结构体的events设置带轮询事项；执行后，会返回轮询的结果 ；<br>
    在返回pollfd，通过revents判断事项是否发生，进而做相应处理。

2. 基本过程同select一样，先通过socket句柄，得到有新的请求；accept建立连接得到新句柄，将新句柄放入poll请求的fds内。<br>
    poll返回后，逐个判断socket句柄、fds中其他句柄，是否有事项，并依次执行。对新连接的句柄，执行结束后，将fds中对应句柄清空(-1)。<br>

3. 由于select处：fds没有数量限制（当然，实现时自己会做限制）；循环时，fds不需要每次都重新设置句柄，也就不需要额外的存储。

### 注意

poll 设置的最大句柄数要+1

## epoll

1. 不需要自己维护句柄，需要先使用epoll_create创建一个epoll的句柄； <br>
    后面通过epoll_ctl向epoll的句柄添加、删除或修改 socket 句柄， <br>
    添加时指定要监听的事件结构体类型(EPOLLIN/EPOLLOUT等等)，该结构体的data.fd 为句柄

2. epoll_wait返回事件结构体集合，结构体中data.fd是句柄，结构体中events是事件类型，根据类型判断是否为想要的待处理事件，并执行相应处理

3. 同select、poll，也是先有socket集合，当有新请求时，建立连接句柄并由epoll_ctl加入；执行完成后，由epoll_ctl删除


## 比较总结

### select

```
缺点：
1、每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；
2、同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大；
3、select支持的文件描述符数量太小了，默认是1024。
优点：
1、select的可移植性更好，在某些Unix系统上不支持poll()。
2、select对于超时值提供了更好的精度：微秒，而poll是毫秒
```

### poll

```
缺点：
1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义；
2、与select一样，poll返回后，需要轮询pollfd来获取就绪的描述符。
优点：
1、poll() 不要求开发者计算最大文件描述符加一的大小。
2、poll() 在应付大数目的文件描述符的时候速度更快，相比于select。
3、它没有最大连接数的限制，原因是它是基于链表来存储的。
```

### epoll

```
1、支持一个进程打开大数目的socket描述符：
    相比select，epoll则没有对FD的限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。

2、IO效率不随FD数目增加而线性下降：
    epoll不存在这个问题，它只会对"活跃"的socket进行操作,
     这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有"活跃"的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个"伪"AIO，因为这时候推动力在os内核。
    在一些 benchmark中，如果所有的socket基本上都是活跃的，比如一个高速LAN环境，epoll并不比select/poll有什么效率，
        相反，如果过多使用epoll_ctl, 效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。

3、使用mmap加速内核与用户空间的消息传递：
    这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。
```

### 最后

```
  1、select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。
      而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。
      虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

  2、select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，
    而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。
```

### SRC
参考 [select、poll、epoll总结](https://www.cnblogs.com/Anker/p/3265058.html) 以及其源代码

